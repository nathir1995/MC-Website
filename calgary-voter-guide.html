<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calgary Voter Guide - Find Your Ward & Candidates</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; color: #333; }
        .container { max-width: 1200px; margin: 0 auto; }
        .header { text-align: center; color: white; margin-bottom: 40px; animation: fadeInDown 0.8s ease; }
        .header h1 { font-size: 3rem; font-weight: 800; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.2); }
        .header p { font-size: 1.2rem; opacity: 0.95; }
        .main-card { background: white; border-radius: 24px; padding: 40px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); animation: fadeInUp 0.8s ease; margin-bottom: 30px; }
        .search-section { margin-bottom: 30px; }
        .input-group { position: relative; margin-bottom: 20px; }
        .input-group label { display: block; font-weight: 600; margin-bottom: 8px; color: #555; font-size: 0.95rem; }
        .address-input-wrapper { position: relative; }
        input[type="text"] { width: 100%; padding: 18px 50px 18px 20px; font-size: 1.1rem; border: 2px solid #e0e0e0; border-radius: 16px; transition: all 0.3s ease; background: #f8f9fa; }
        input[type="text"]:focus { outline: none; border-color: #667eea; background: white; box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1); }
        .input-icon { position: absolute; right: 18px; top: 50%; transform: translateY(-50%); color: #999; }
        .autocomplete-dropdown { position: absolute; top: 100%; left: 0; right: 0; background: white; border: 2px solid #e0e0e0; border-top: none; border-radius: 0 0 16px 16px; max-height: 300px; overflow-y: auto; z-index: 1000; box-shadow: 0 10px 30px rgba(0,0,0,0.1); display: none; }
        .autocomplete-dropdown.active { display: block; }
        .autocomplete-item { padding: 15px 20px; cursor: pointer; border-bottom: 1px solid #f0f0f0; transition: background 0.2s; }
        .autocomplete-item:hover { background: #f8f9fa; }
        .search-btn { width: 100%; padding: 18px; font-size: 1.2rem; font-weight: 700; color: white; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; border-radius: 16px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); }
        .search-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6); }
        .alert { padding: 16px 20px; border-radius: 12px; margin-bottom: 20px; display: flex; align-items: center; gap: 12px; animation: slideIn 0.4s ease; }
        .alert-error { background: #fee; border: 2px solid #fcc; color: #c33; }
        .alert-success { background: #efe; border: 2px solid #cfc; color: #3c3; }
        .alert-info { background: #eef; border: 2px solid #ccf; color: #33c; }
        .ward-badge { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 20px; text-align: center; margin-bottom: 30px; box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3); animation: scaleIn 0.5s ease; }
        .ward-badge h2 { font-size: 1.5rem; margin-bottom: 10px; opacity: 0.9; }
        .ward-badge .ward-number { font-size: 4rem; font-weight: 900; text-shadow: 2px 2px 4px rgba(0,0,0,0.2); }
        .candidates-section { margin-bottom: 30px; }
        .section-title { font-size: 1.8rem; font-weight: 700; margin-bottom: 20px; color: #333; display: flex; align-items: center; gap: 12px; }
        .section-icon { width: 40px; height: 40px; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; }
        .mayor-icon { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        .councillor-icon { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
        .candidate-list { display: flex; flex-direction: column; gap: 15px; }
        .candidate-card { background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); padding: 20px 25px; border-radius: 16px; display: flex; align-items: center; gap: 20px; transition: all 0.3s ease; border: 2px solid transparent; }
        .candidate-card:hover { transform: translateX(8px); border-color: #667eea; box-shadow: 0 8px 20px rgba(0,0,0,0.1); }
        .candidate-name { font-size: 1.3rem; font-weight: 600; color: #333; text-decoration: none; }
        .candidate-name:hover { color: #667eea; }
        .loading { text-align: center; padding: 40px; color: #999; }
        .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #667eea; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin: 0 auto 20px; }
        /* Results grid */
        .results-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 16px; margin-top: 16px; }
        .results-col { background: #fff; border: 1px solid #e5e7eb; border-radius: 12px; padding: 16px; }
        .results-col h3 { font-size: 1.2rem; font-weight: 800; margin-bottom: 12px; display:flex; align-items:center; gap:8px; color:#111; }
        .results-col .candidate-list { gap: 10px; }
        @keyframes fadeInDown { from { opacity: 0; transform: translateY(-30px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(30px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes slideIn { from { opacity: 0; transform: translateX(-20px); } to { opacity: 1; transform: translateX(0); } }
        @keyframes scaleIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üó≥Ô∏è Calgary Voter Guide</h1>
            <p>Find your ward and candidates</p>
        </div>
        <div class="main-card">
            <div class="search-section">
                <div class="input-group">
                    <label for="addressInput">Enter Your Address or Postal Code</label>
                    <div class="address-input-wrapper">
                        <input type="text" id="addressInput" placeholder="123 Main St SW, Calgary or T2P 3M5" autocomplete="off">
                        <span class="input-icon">üìç</span>
                        <div id="autocompleteDropdown" class="autocomplete-dropdown"></div>
                    </div>
                </div>
                <button class="search-btn" onclick="searchWard()">üîç Find My Ward & Candidates</button>
            </div>
            <div id="alertContainer"></div>
            <div id="resultsContainer"></div>
        </div>
    </div>
    <script>
        const GOOGLE_MAPS_API_KEY = 'AIzaSyDrt3pufqoeYZlipaTBmYPvpBMSRwwdg9s';
        let wardIndex = { community: {} };
        let addressIndex = {}; // normalizedAddress -> community
        let addressIndexLoaded = false;
        let addressDatasetRows = null; // cached rows for testing
        let trackerCandidates = null;
        let autocompleteService = null;
        let geocoder = null;
        // Prevent recursive/infinite geocoding flows
        let isCurrentlyGeocoding = false;
        const addressInput = document.getElementById('addressInput');
        const dropdown = document.getElementById('autocompleteDropdown');
        let debounceTimer;

        function initGoogleMaps() {
            const script = document.createElement('script');
            script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_MAPS_API_KEY}&libraries=places&callback=initServices`;
            script.async = true;
            script.defer = true;
            script.onerror = () => {
                showAlert('Failed to load Google Maps. Check API key and referrer restrictions.', 'error');
                console.error('Google Maps JS failed to load');
            };
            document.head.appendChild(script);
        }

        function initServices() {
            autocompleteService = new google.maps.places.AutocompleteService();
            geocoder = new google.maps.Geocoder();
            console.log('Google Maps initialized');
        }
        // Ensure callback is globally accessible
        window.initServices = initServices;

        // Timeout helper to prevent infinite loading states
        function withTimeout(promise, timeoutMs = 10000) {
            return Promise.race([
                promise,
                new Promise((_, reject) => setTimeout(() => reject(new Error('Request timeout')), timeoutMs))
            ]);
        }

        async function loadAddressDataset() {
            try {
                const url = 'https://ajgqyygtstihrwjovhes.supabase.co/storage/v1/object/public/YYC%20addresses/filtered_property_data.json';
                const res = await fetch(url, { cache: 'no-store' });
                if (!res.ok) return;
                const json = await res.json();
                const rows = Array.isArray(json) ? json : (json && (json.rows || json.data)) || [];
                if (!Array.isArray(rows)) return;
                const sample = rows[0] || {};
                const { addressKey, communityKey } = detectAddressJsonKeys(sample);
                if (!addressKey || !communityKey) return;
                const idx = {};
                let count = 0;
                for (const row of rows) {
                    const addr = String(row[addressKey] ?? '').trim();
                    const community = String(row[communityKey] ?? '').trim();
                    if (!addr || !community) continue;
                    idx[normalizeAddress(addr)] = community;
                    count++;
                }
                if (count > 0) {
                    addressIndex = idx;
                    addressIndexLoaded = true;
                    console.log('Address index loaded:', count);
                    addressDatasetRows = rows;
                }
            } catch (e) {
                console.warn('Failed to load address dataset', e);
            }
        }

        // ---------- Test helpers (invoke from console) ----------
        async function ensureMappingLoaded() {
            if (Object.keys(wardIndex.community).length > 0) return;
            await loadWardMapping();
        }

        async function ensureDatasetRowsLoaded() {
            if (addressDatasetRows && Array.isArray(addressDatasetRows)) return;
            await loadAddressDataset();
        }

        function sampleWardAddressesFromDataset(perWard = 2) {
            const rows = addressDatasetRows || [];
            if (!rows.length) return {};
            const { addressKey, communityKey } = detectAddressJsonKeys(rows[0] || {});
            const samples = {};
            for (const row of rows) {
                const addr = String(row[addressKey] ?? '').trim();
                const community = String(row[communityKey] ?? '').trim();
                const key = normalizeKey(community);
                const ward = wardIndex.community[key];
                if (!ward || !addr) continue;
                const w = String(ward);
                if (!samples[w]) samples[w] = [];
                if (samples[w].length < perWard) samples[w].push(addr);
                if (Object.keys(samples).length >= 14 && Object.values(samples).every(a => a.length >= perWard)) break;
            }
            return samples;
        }

        // Dataset-only verification (no Google API calls)
        window.runWardTestsDataset = async function(perWard = 2) {
            await ensureMappingLoaded();
            await ensureDatasetRowsLoaded();
            const samples = sampleWardAddressesFromDataset(perWard);
            const results = [];
            for (const [ward, addrs] of Object.entries(samples)) {
                for (const addr of addrs) {
                    const fromDataset = lookupInDataset(addr);
                    const expected = ward;
                    const foundWard = fromDataset ? wardIndex.community[normalizeKey(fromDataset)] : null;
                    const ok = String(foundWard) === String(expected);
                    results.push({ ward: expected, addr, community: fromDataset, foundWard, ok });
                }
            }
            const pass = results.filter(r => r.ok).length;
            const fail = results.length - pass;
            console.table(results);
            console.log(`Dataset tests: ${pass}/${results.length} passed, ${fail} failed`);
            return { pass, fail, results };
        };

        // Geocode-based verification (calls Google; beware of quotas)
        window.runWardTestsGeocode = async function(perWard = 1, delayMs = 1200) {
            await ensureMappingLoaded();
            await ensureDatasetRowsLoaded();
            if (!geocoder) { console.warn('Geocoder not ready'); return; }
            const samples = sampleWardAddressesFromDataset(perWard);
            const results = [];

            const geocodeOnce = (query) => withTimeout(new Promise((resolve, reject) => {
                geocoder.geocode({ address: query + ', Calgary, AB', region: 'ca' }, (res, status) => {
                    if (status === 'OK') resolve(res);
                    else reject(new Error(status));
                });
            }), 8000);

            for (const [ward, addrs] of Object.entries(samples)) {
                for (const addr of addrs) {
                    try {
                        await new Promise(r => setTimeout(r, delayMs));
                        const res = await geocodeOnce(addr);
                        const best = res[0];
                        let foundCommunity = null;
                        // Try dataset variations on formatted address
                        if (best && best.formatted_address) {
                            const ds = lookupInDataset(best.formatted_address);
                            if (ds) foundCommunity = ds;
                        }
                        if (!foundCommunity) {
                            foundCommunity = getCommunityFromComponents((best && best.address_components) || []);
                        }
                        const foundWard = foundCommunity ? wardIndex.community[normalizeKey(foundCommunity)] : null;
                        const ok = String(foundWard) === String(ward);
                        results.push({ ward, addr, community: foundCommunity, foundWard, ok });
                    } catch (e) {
                        results.push({ ward, addr, error: e.message, ok: false });
                    }
                }
            }
            const pass = results.filter(r => r.ok).length;
            const fail = results.length - pass;
            console.table(results);
            console.log(`Geocode tests: ${pass}/${results.length} passed, ${fail} failed`);
            return { pass, fail, results };
        };

        async function loadWardMapping() {
            try {
                for (let i = 1; i <= 14; i++) {
                    try {
                        const r = await fetch(`assets/data/calgary/wards/ward-${i}.json`);
                        if (r.ok) {
                            const arr = await r.json();
                            arr.forEach(name => { wardIndex.community[normalizeKey(name)] = String(i); });
                        }
                    } catch (e) { console.warn(`Ward ${i} not found`); }
                }
                console.log('Ward mapping loaded:', Object.keys(wardIndex.community).length);
            } catch (e) { console.error('Failed to load wards:', e); }
        }

        async function loadTrackerCandidates() {
            try {
                const res = await fetch('calgary-2025.html');
                if (!res.ok) return;
                const html = await res.text();
                const re = /const\s+candidates\s*=\s*\[(.*?)\];/s;
                const m = re.exec(html);
                if (!m) return;
                trackerCandidates = Function('"use strict"; return [' + m[1] + '];')();
                console.log('Loaded candidates:', trackerCandidates.length);
            } catch (e) { console.error('Failed to load candidates:', e); }
        }

        addressInput.addEventListener('input', function(e) {
            clearTimeout(debounceTimer);
            const value = e.target.value.trim();

            // If input was cleared, remove all results and suggestions
            if (!value) {
                dropdown.classList.remove('active');
                dropdown.innerHTML = '';
                const resultsEl = document.getElementById('resultsContainer');
                const alertEl = document.getElementById('alertContainer');
                if (resultsEl) resultsEl.innerHTML = '';
                if (alertEl) alertEl.innerHTML = '';
                // Also reset any in-flight geocoding guard
                isCurrentlyGeocoding = false;
                return;
            }
            const completePostalPattern = /^[A-Za-z]\d[A-Za-z][\s-]?\d[A-Za-z]\d$/;
            if (completePostalPattern.test(value)) {
                dropdown.classList.remove('active');
                debounceTimer = setTimeout(() => searchWard(), 500);
                return;
            }
            const partialPostalPattern = /^[A-Za-z]\d[A-Za-z][\s-]?\d?[A-Za-z]?\d?$/;
            if (partialPostalPattern.test(value)) {
                dropdown.classList.remove('active');
                return;
            }
            if (!value || value.length < 3 || !autocompleteService) {
                dropdown.classList.remove('active');
                return;
            }
            debounceTimer = setTimeout(() => {
                const bounds = new google.maps.LatLngBounds(
                    new google.maps.LatLng(50.8429, -114.3144),
                    new google.maps.LatLng(51.2139, -113.8668)
                );
                autocompleteService.getPlacePredictions({
                    input: value,
                    componentRestrictions: { country: 'ca' },
                    bounds
                }, displaySuggestions);
            }, 300);
        });

        function displaySuggestions(predictions, status) {
            dropdown.innerHTML = '';
            const ok = (google.maps.places.PlacesServiceStatus && google.maps.places.PlacesServiceStatus.OK)
              || (google.maps.places.AutocompleteServiceStatus && google.maps.places.AutocompleteServiceStatus.OK);
            if (status !== ok || !predictions || predictions.length === 0) {
                dropdown.classList.remove('active');
                if (typeof status === 'string' && status !== ok) {
                    // Surface common misconfigurations for easier debugging
                    if (status === 'REQUEST_DENIED') {
                        showAlert('Autocomplete request denied. Ensure Places API is enabled and referrer/domain is allowed.', 'error');
                    } else if (status === 'INVALID_REQUEST') {
                        showAlert('Invalid autocomplete request. Try typing a fuller address.', 'error');
                    }
                }
                return;
            }
            predictions.forEach(prediction => {
                const item = document.createElement('div');
                item.className = 'autocomplete-item';
                item.textContent = prediction.description;
                item.addEventListener('click', () => {
                    addressInput.value = prediction.description;
                    dropdown.classList.remove('active');
                    // Prefer dataset match first
                    const fromDataset = addressIndex[normalizeAddress(prediction.description)];
                    if (fromDataset) {
                        lookupByCommunity(fromDataset, { source: 'Address dataset' });
                    } else {
                        geocodeAddress(prediction.description);
                    }
                });
                dropdown.appendChild(item);
            });
            dropdown.classList.add('active');
        }

        function searchWard() {
            const address = addressInput.value.trim();
            if (!address) { showAlert('Please enter an address', 'error'); return; }
            if (!geocoder) { showAlert('Google Maps not ready. Please wait a moment and try again.', 'error'); return; }
            if (Object.keys(wardIndex.community).length === 0) { showAlert('Ward mapping not loaded. Please refresh the page.', 'info'); return; }
            console.log('Starting search for:', address);
            console.log('Dataset loaded:', addressIndexLoaded);
            console.log('Ward communities loaded:', Object.keys(wardIndex.community).length);
            // Dataset first with multiple normalization variants
            const fromDataset = lookupInDataset(address);
            if (fromDataset) {
                console.log('Found in dataset immediately:', fromDataset);
                lookupByCommunity(fromDataset, { source: 'Address dataset' });
                return;
            }
            geocodeAddress(address);
        }

        function geocodeAddress(address) {
            // Prevent recursive calls
            if (isCurrentlyGeocoding) {
                console.log('Already geocoding, skipping recursive call');
                return;
            }
            isCurrentlyGeocoding = true;
            showLoading();
            const geocodePromise = new Promise((resolve, reject) => {
                geocoder.geocode({ address: address + ', Calgary, AB', region: 'ca' }, (results, status) => {
                    if (status === 'OK') resolve(results);
                    else reject(new Error(`Geocoding failed: ${status}`));
                });
            });
            withTimeout(geocodePromise, 8000)
                .then((results) => {
                    if (!results || !results.length) { showAlert('Address not found', 'error'); hideLoading(); isCurrentlyGeocoding = false; return; }
                    const best = results[0];
                    console.log('Geocode result:', best);
                    if (best.formatted_address) {
                        const fromDataset = lookupInDataset(best.formatted_address);
                        if (fromDataset) { console.log('Found in dataset:', fromDataset); isCurrentlyGeocoding = false; lookupByCommunity(fromDataset, { source: 'Address dataset' }); return; }
                    }
                    const community = getCommunityFromComponents(best.address_components || []);
                    console.log('Extracted community:', community);
                    if (community && !isGenericLocation(community)) { isCurrentlyGeocoding = false; lookupByCommunity(community, { source: 'Google Geocoding' }); return; }
                    if (best.geometry && best.geometry.location) { /* keep flag true; reverse will reset */ reverseGeocodeForCommunity(best.geometry.location); return; }
                    showAlert('Could not determine community. Try a more complete street address.', 'error'); hideLoading(); isCurrentlyGeocoding = false;
                })
                .catch((error) => { console.error('Geocoding error:', error); showAlert('Failed to geocode address: ' + error.message, 'error'); hideLoading(); isCurrentlyGeocoding = false; });
        }

        function getCommunityFromComponents(components) {
            if (!components) return null;
            console.log('All address components:', (components || []).map(c => ({ name: c.long_name, types: c.types })));
            let candidates = {
                neighborhood: null,
                sublocality1: null,
                sublocality: null,
                political: null,
                colloquial: null
            };
            components.forEach(component => {
                const types = component.types || [];
                const name = component.long_name;
                const isTooGeneric = types.some(t =>
                    t === 'country' ||
                    t === 'administrative_area_level_1' ||
                    t === 'administrative_area_level_2' ||
                    t === 'locality' ||
                    t === 'postal_code'
                );
                if (isTooGeneric) {
                    console.log('Skipping too generic:', name, types);
                    return;
                }
                if (types.includes('neighborhood')) {
                    candidates.neighborhood = name;
                    console.log('Found neighborhood:', name);
                }
                if (types.includes('sublocality_level_1')) {
                    candidates.sublocality1 = name;
                    console.log('Found sublocality_level_1:', name);
                }
                if (types.includes('sublocality')) {
                    candidates.sublocality = name;
                    console.log('Found sublocality:', name);
                }
                if (types.includes('colloquial_area')) {
                    candidates.colloquial = name;
                    console.log('Found colloquial_area:', name);
                }
                if (types.includes('political') && !types.includes('locality')) {
                    candidates.political = name;
                    console.log('Found political:', name);
                }
            });
            console.log('All candidates:', candidates);
            const priority = ['neighborhood', 'sublocality1', 'sublocality', 'colloquial', 'political'];
            for (const key of priority) {
                const candidate = candidates[key];
                if (candidate && !isGenericLocation(candidate)) {
                    console.log(`Selected ${key}:`, candidate);
                    return candidate;
                }
            }
            console.log('No valid community found in components');
            return null;
        }

        function isGenericLocation(name) {
            if (!name) return true;
            const normalized = normalizeKey(name);
            const generic = [
                'CALGARY',
                'NORTH EAST','NORTHEAST','NE',
                'NORTH WEST','NORTHWEST','NW',
                'SOUTH EAST','SOUTHEAST','SE',
                'SOUTH WEST','SOUTHWEST','SW',
                'DOWNTOWN','INNER CITY','DOWNTOWN CALGARY',
                'ALBERTA','AB',
                'CANADA','CA',
                'CITY OF CALGARY','CALGARY ALBERTA'
            ];
            if (generic.includes(normalized)) {
                console.log('Filtered out generic location:', name);
                return true;
            }
            if (normalized.endsWith(' CALGARY')) {
                const withoutCalgary = normalized.replace(/ CALGARY$/, '');
                if (generic.includes(withoutCalgary)) {
                    console.log('Filtered out generic location (ends with CALGARY):', name);
                    return true;
                }
            }
            return false;
        }

        function findPartialCommunityMatch(searchKey) {
            const key = normalizeKey(searchKey)
                .replace(/\s(NE|NW|SE|SW)$/g, '')
                .replace(/\sCALGARY$/g, '')
                .trim();
            if (key.length < 3) return null;
            const communities = Object.keys(wardIndex.community);
            for (const communityKey of communities) {
                if (communityKey.includes(key) || key.includes(communityKey)) {
                    return { ward: wardIndex.community[communityKey], name: communityKey };
                }
            }
            return null;
        }

        function reverseGeocodeForCommunity(location) {
            console.log('Reverse geocoding at:', location);
            const reversePromise = new Promise((resolve, reject) => {
                geocoder.geocode({ location }, (results, status) => {
                    if (status === 'OK') resolve(results);
                    else reject(new Error(`Reverse geocoding failed: ${status}`));
                });
            });
            withTimeout(reversePromise, 8000)
                .then((results) => {
                    if (!results || !results.length) { showAlert('Could not determine community', 'error'); hideLoading(); isCurrentlyGeocoding = false; return; }
                    console.log(`Reverse geocode returned ${results.length} results`);
                    // Strategy 1: dataset check across many results
                    if (addressIndexLoaded) {
                        for (let i = 0; i < Math.min(results.length, 20); i++) {
                            const result = results[i];
                            if (result.formatted_address) {
                                const fromDataset = lookupInDataset(result.formatted_address);
                                if (fromDataset) { console.log(`Found in dataset at result ${i}:`, fromDataset); isCurrentlyGeocoding = false; lookupByCommunity(fromDataset, { source: 'Address dataset (reverse)' }); return; }
                            }
                        }
                    }
                    // Strategy 2: strict extraction across many results, with fuzzy fallback
                    for (let i = 0; i < Math.min(results.length, 20); i++) {
                        const result = results[i];
                        console.log(`Checking result ${i}:`, result.formatted_address);
                        const community = getCommunityFromComponents(result.address_components || []);
                        console.log(`Community from result ${i}:`, community);
                        if (community && !isGenericLocation(community)) {
                            const key = normalizeKey(community);
                            const ward = wardIndex.community[key];
                            if (ward) { console.log('Found valid community:', community, 'Ward:', ward); isCurrentlyGeocoding = false; lookupByCommunity(community, { source: 'Reverse geocoding' }); return; }
                            // Try fuzzy
                            const fuzzy = findPartialCommunityMatch(key);
                            if (fuzzy) { console.log('Fuzzy match succeeded:', fuzzy); isCurrentlyGeocoding = false; displayResults(fuzzy.ward, { community: fuzzy.name, note: 'Approximate match', source: 'Reverse geocoding (fuzzy)' }); return; }
                        }
                    }
                    // Strategy 3: lenient extraction (accept more component types), then fuzzy
                    console.log('Standard extraction failed, trying lenient extraction...');
                    for (let i = 0; i < Math.min(results.length, 20); i++) {
                        const result = results[i];
                        const lenientCommunity = getLenientCommunityFromComponents(result.address_components || []);
                        if (lenientCommunity && !isGenericLocation(lenientCommunity)) {
                            const key = normalizeKey(lenientCommunity);
                            const ward = wardIndex.community[key];
                            if (ward) { console.log('Found with lenient extraction:', lenientCommunity); isCurrentlyGeocoding = false; lookupByCommunity(lenientCommunity, { source: 'Reverse geocoding (lenient)' }); return; }
                            const fuzzy = findPartialCommunityMatch(key);
                            if (fuzzy) { console.log('Lenient + fuzzy match:', fuzzy); isCurrentlyGeocoding = false; displayResults(fuzzy.ward, { community: fuzzy.name, note: 'Approximate match', source: 'Reverse geocoding (lenient fuzzy)' }); return; }
                        }
                    }
                    console.log('All reverse geocoding strategies failed');
                    showAlert('Could not find a specific community for this address. Please try a nearby address or contact support.', 'error'); hideLoading(); isCurrentlyGeocoding = false;
                })
                .catch((error) => { console.error('Reverse geocoding error:', error); showAlert('Failed to reverse geocode: ' + error.message, 'error'); hideLoading(); isCurrentlyGeocoding = false; });
        }

        function getLenientCommunityFromComponents(components) {
            if (!components) return null;
            console.log('Lenient extraction - all components:', (components || []).map(c => ({ name: c.long_name, types: c.types })));
            const candidates = [];
            components.forEach(component => {
                const types = component.types || [];
                const name = component.long_name;
                const isCountryOrProvince = types.some(t => t === 'country' || t === 'administrative_area_level_1' || t === 'postal_code');
                if (isCountryOrProvince) return;
                if (types.includes('neighborhood') || types.includes('sublocality') || types.includes('sublocality_level_1') || types.includes('colloquial_area') || types.includes('political')) {
                    candidates.push({ name, priority: types.includes('neighborhood') ? 1 : types.includes('sublocality_level_1') ? 2 : types.includes('sublocality') ? 3 : types.includes('colloquial_area') ? 4 : 5 });
                }
            });
            candidates.sort((a, b) => a.priority - b.priority);
            console.log('Lenient candidates:', candidates);
            for (const c of candidates) {
                if (!isGenericLocation(c.name)) { console.log('Lenient extraction selected:', c.name); return c.name; }
            }
            return null;
        }

        function lookupByCommunityWithFallback(community, originalAddress, options = {}) {
            console.log('lookupByCommunityWithFallback called:', community, options);
            const key = normalizeKey(community);
            const ward = wardIndex.community[key];
            if (ward) {
                console.log('Ward found:', ward);
                displayResults(ward, { ...options, community });
                return;
            }
            console.log('Ward not found, trying fuzzy match');
            const partialMatch = findPartialCommunityMatch(key);
            if (partialMatch) {
                console.log('Fuzzy match found:', partialMatch);
                displayResults(partialMatch.ward, { ...options, community: partialMatch.name, note: 'Matched using similar community name' });
                return;
            }
            // Do NOT recursively call geocodeAddress here; avoid infinite loops.
            console.log('No match found for community:', community);
            showAlert(`Community "${community}" not found in ward mapping. Please try entering your full street address with house number.`, 'error');
            hideLoading();
        }

        function lookupByCommunity(community, options = {}) {
            console.log('lookupByCommunity called:', community, options);
            lookupByCommunityWithFallback(community, addressInput.value.trim(), options);
        }

        function displayResults(ward, options = {}) {
            hideLoading();
            dropdown.classList.remove('active');
            const { mayors, councillors, cbe, ccsd } = getCandidatesForWard(ward);
            const header = `<div class="alert alert-success"><span>‚úÖ</span><span>Matched${options.community ? ` ‚Äì ${options.community}` : ''}${options.note ? ` (${options.note})` : ''}</span></div>` +
                           `<div class="ward-badge"><h2>Your Ward</h2><div class="ward-number">Ward ${ward}</div></div>`;

            const col = (title, icon, list) => `
              <div class="results-col">
                <h3><span class="section-icon">${icon}</span>${title}</h3>
                <div class="candidate-list">
                  ${list.length ? list.map(c => {
                    const name = c.url ? `<a href="${c.url}" target="_blank" rel="noopener" class="candidate-name">${c.name}</a>` : `<span class="candidate-name">${c.name}</span>`;
                    return `<div class="candidate-card">${name}</div>`;
                  }).join('') : '<div class="alert alert-info">No entries</div>'}
                </div>
              </div>`;

            const grid = `
              <div class="results-grid">
                ${col('Mayor', 'üë§', mayors)}
                ${col(`Councillor (Ward ${ward})`, 'üë•', councillors)}
                ${col('CBE Trustees', 'üè´', cbe)}
                ${col('CCSD Trustees', '‚õ™', ccsd)}
              </div>`;

            document.getElementById('resultsContainer').innerHTML = header + grid;
        }

        function getCandidatesForWard(ward) {
            const wardStr = String(ward);
            const empty = { mayors: [], councillors: [], cbe: [], ccsd: [] };
            if (!Array.isArray(trackerCandidates)) return empty;
            const mayors = trackerCandidates.filter(c => c.position === 'Mayor');
            const councillors = trackerCandidates.filter(c => c.position === 'Councillor' && String(c.ward) === wardStr);
            // Map ward number to board ward strings used in tracker data
            const cbePairs = {
              '1': ['1 & 2'], '2': ['1 & 2'], '3': ['3 & 4'], '4': ['3 & 4'],
              '5': ['5 & 10'], '10': ['5 & 10'], '6': ['6 & 7'], '7': ['6 & 7'],
              '8': ['8 & 9'], '9': ['8 & 9'], '11': ['11 & 13'], '13': ['11 & 13'],
              '12': ['12 & 14'], '14': ['12 & 14']
            };
            const ccsdPairs = {
              '1': ['1, 2 & Cochrane'], '2': ['1, 2 & Cochrane'],
              '4': ['4 & 7'], '7': ['4 & 7'], '6': ['6 & 8'], '8': ['6 & 8'],
              '9': ['9 & 10'], '10': ['9 & 10'], '11': ['11 & 12'], '12': ['11 & 12'],
              '13': ['13 & 14'], '14': ['13 & 14']
            };
            const cbe = trackerCandidates.filter(c => c.position === 'CBE Trustee' && (cbePairs[wardStr] || []).includes(String(c.ward)));
            const ccsd = trackerCandidates.filter(c => c.position === 'CCSD Trustee' && (ccsdPairs[wardStr] || []).includes(String(c.ward)));
            return { mayors, councillors, cbe, ccsd };
        }

        function showAlert(message, type) {
            const icons = { error: '‚ùå', success: '‚úÖ', info: '‚ÑπÔ∏è' };
            document.getElementById('alertContainer').innerHTML = `<div class="alert alert-${type}"><span>${icons[type]}</span><span>${message}</span></div>`;
            setTimeout(() => { document.getElementById('alertContainer').innerHTML = ''; }, 5000);
        }

        function showLoading() {
            document.getElementById('resultsContainer').innerHTML = `<div class="loading"><div class="spinner"></div><p>Searching...</p></div>`;
        }

        function hideLoading() {
            const loadingDiv = document.querySelector('.loading');
            if (loadingDiv) loadingDiv.remove();
        }

        function normalizeKey(value) {
            return value.toUpperCase().trim()
                .replace(/\./g, '')
                .replace(/-/g, ' ')
                .replace(/\//g, ' ')
                .replace(/\s+/g, ' ')
                .replace(/\bN\s*E\b/g, 'NE')
                .replace(/\bN\s*W\b/g, 'NW')
                .replace(/\bS\s*E\b/g, 'SE')
                .replace(/\bS\s*W\b/g, 'SW')
                .replace(/\bNORTH\s*EAST\b/g, 'NE')
                .replace(/\bNORTH\s*WEST\b/g, 'NW')
                .replace(/\bSOUTH\s*EAST\b/g, 'SE')
                .replace(/\bSOUTH\s*WEST\b/g, 'SW');
        }

        function normalizeAddressVariations(value) {
            const base = (value || '')
                .toUpperCase()
                .trim()
                .replace(/,\s*CANADA$/i, '')
                .replace(/,\s*ALBERTA$/i, '')
                .replace(/,\s*AB$/i, '')
                .replace(/,\s*CALGARY$/i, '')
                .replace(/\./g, '')
                .replace(/\s+/g, ' ')
                .replace(/\bNORTH[\s-]?EAST\b/g, 'NE')
                .replace(/\bNORTH[\s-]?WEST\b/g, 'NW')
                .replace(/\bSOUTH[\s-]?EAST\b/g, 'SE')
                .replace(/\bSOUTH[\s-]?WEST\b/g, 'SW');
            const abbreviated = base
                .replace(/\bSTREET\b/g, 'ST')
                .replace(/\bAVENUE\b/g, 'AVE')
                .replace(/\bROAD\b/g, 'RD')
                .replace(/\bDRIVE\b/g, 'DR');
            const full = base
                .replace(/\bST\b/g, 'STREET')
                .replace(/\bAVE\b/g, 'AVENUE')
                .replace(/\bRD\b/g, 'ROAD')
                .replace(/\bDR\b/g, 'DRIVE');
            return Array.from(new Set([base, abbreviated, full]));
        }

        function lookupInDataset(address) {
            if (!addressIndexLoaded) return null;
            const variations = normalizeAddressVariations(address);
            console.log('Trying address variations:', variations);
            for (const variant of variations) {
                if (addressIndex[variant]) {
                    console.log('Found match with variation:', variant, '‚Üí', addressIndex[variant]);
                    return addressIndex[variant];
                }
            }
            return null;
        }

        function detectAddressJsonKeys(sample) {
            const keys = Object.keys(sample || {});
            let addressKey = null, communityKey = null;
            keys.forEach(k => {
                const l = k.toLowerCase();
                if (!addressKey && (l.includes('address') || l.includes('full_address') || l.includes('street'))) addressKey = k;
                if (!communityKey && (l === 'com_name' || l.includes('community') || l.includes('neigh'))) communityKey = k;
            });
            return { addressKey, communityKey };
        }

        document.addEventListener('click', function(e) {
            if (!addressInput.contains(e.target) && !dropdown.contains(e.target)) {
                dropdown.classList.remove('active');
            }
        });

        addressInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                dropdown.classList.remove('active');
                searchWard();
            }
        });

        initGoogleMaps();
        loadWardMapping();
        loadAddressDataset();
        loadTrackerCandidates();
    </script>
</body>
</html>
