<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calgary Voter Guide - Find Your Ward & Candidates</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; color: #333; }
        .container { max-width: 1200px; margin: 0 auto; }
        .header { text-align: center; color: white; margin-bottom: 40px; animation: fadeInDown 0.8s ease; }
        .header h1 { font-size: 3rem; font-weight: 800; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.2); }
        .header p { font-size: 1.2rem; opacity: 0.95; }
        .main-card { background: white; border-radius: 24px; padding: 40px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); animation: fadeInUp 0.8s ease; margin-bottom: 30px; }
        .search-section { margin-bottom: 30px; }
        .input-group { position: relative; margin-bottom: 20px; }
        .input-group label { display: block; font-weight: 600; margin-bottom: 8px; color: #555; font-size: 0.95rem; }
        .address-input-wrapper { position: relative; }
        input[type="text"] { width: 100%; padding: 18px 50px 18px 20px; font-size: 1.1rem; border: 2px solid #e0e0e0; border-radius: 16px; transition: all 0.3s ease; background: #f8f9fa; }
        input[type="text"]:focus { outline: none; border-color: #667eea; background: white; box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1); }
        .input-icon { position: absolute; right: 18px; top: 50%; transform: translateY(-50%); color: #999; }
        .autocomplete-dropdown { position: absolute; top: 100%; left: 0; right: 0; background: white; border: 2px solid #e0e0e0; border-top: none; border-radius: 0 0 16px 16px; max-height: 300px; overflow-y: auto; z-index: 1000; box-shadow: 0 10px 30px rgba(0,0,0,0.1); display: none; }
        .autocomplete-dropdown.active { display: block; }
        .autocomplete-item { padding: 15px 20px; cursor: pointer; border-bottom: 1px solid #f0f0f0; transition: background 0.2s; }
        .autocomplete-item:hover { background: #f8f9fa; }
        .search-btn { width: 100%; padding: 18px; font-size: 1.2rem; font-weight: 700; color: white; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; border-radius: 16px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); }
        .search-btn:hover:not(:disabled) { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6); }
        .search-btn:disabled { opacity: 0.6; cursor: not-allowed; }
        .alert { padding: 16px 20px; border-radius: 12px; margin-bottom: 20px; display: flex; align-items: center; gap: 12px; animation: slideIn 0.4s ease; }
        .alert-error { background: #fee; border: 2px solid #fcc; color: #c33; }
        .alert-success { background: #efe; border: 2px solid #cfc; color: #3c3; }
        .alert-info { background: #eef; border: 2px solid #ccf; color: #33c; }
        .alert-warning { background: #fff3cd; border: 2px solid #ffc107; color: #856404; }
        .ward-badge { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 20px; text-align: center; margin-bottom: 30px; box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3); animation: scaleIn 0.5s ease; }
        .ward-badge h2 { font-size: 1.5rem; margin-bottom: 10px; opacity: 0.9; }
        .ward-badge .ward-number { font-size: 4rem; font-weight: 900; text-shadow: 2px 2px 4px rgba(0,0,0,0.2); }
        .candidates-section { margin-bottom: 30px; }
        .section-title { font-size: 1.8rem; font-weight: 700; margin-bottom: 20px; color: #333; display: flex; align-items: center; gap: 12px; }
        .section-icon { width: 40px; height: 40px; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; }
        .mayor-icon { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        .councillor-icon { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
        .candidate-list { display: flex; flex-direction: column; gap: 15px; }
        .candidate-card { background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); padding: 20px 25px; border-radius: 16px; display: flex; align-items: center; gap: 20px; transition: all 0.3s ease; border: 2px solid transparent; }
        .candidate-card:hover { transform: translateX(8px); border-color: #667eea; box-shadow: 0 8px 20px rgba(0,0,0,0.1); }
        .candidate-name { font-size: 1.3rem; font-weight: 600; color: #333; text-decoration: none; }
        .candidate-name:hover { color: #667eea; }
        .loading { text-align: center; padding: 40px; color: #999; }
        .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #667eea; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin: 0 auto 20px; }
        .results-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 16px; margin-top: 16px; }
        .results-col { background: #fff; border: 1px solid #e5e7eb; border-radius: 12px; padding: 16px; }
        .results-col h3 { font-size: 1.2rem; font-weight: 800; margin-bottom: 12px; display:flex; align-items:center; gap:8px; color:#111; }
        .results-col .candidate-list { gap: 10px; }
        
        /* Mobile Responsive */
        @media (max-width: 768px) {
            .header h1 { font-size: 2rem; }
            .header p { font-size: 1rem; }
            .main-card { padding: 20px; }
            .search-btn { padding: 20px; font-size: 1.1rem; min-height: 60px; }
            input[type="text"] { font-size: 16px; padding: 16px 45px 16px 16px; }
            .candidate-card { padding: 15px; }
            .ward-badge .ward-number { font-size: 3rem; }
            .results-grid { grid-template-columns: 1fr; }
        }
        
        @keyframes fadeInDown { from { opacity: 0; transform: translateY(-30px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(30px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes slideIn { from { opacity: 0; transform: translateX(-20px); } to { opacity: 1; transform: translateX(0); } }
        @keyframes scaleIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üó≥Ô∏è Calgary Voter Guide</h1>
            <p>Find your ward and candidates</p>
        </div>
        <div class="main-card">
            <div class="search-section">
                <div class="input-group">
                    <label for="addressInput">Enter Your Address or Postal Code</label>
                    <div class="address-input-wrapper">
                        <input type="text" id="addressInput" placeholder="123 Main St SW, Calgary or T2P 3M5" autocomplete="off">
                        <span class="input-icon">üìç</span>
                        <div id="autocompleteDropdown" class="autocomplete-dropdown"></div>
                    </div>
                </div>
                <button class="search-btn" id="searchBtn" onclick="searchWard()">üîç Find My Ward & Candidates</button>
            </div>
            <div id="alertContainer"></div>
            <div id="resultsContainer"></div>
        </div>
    </div>
    
    <script src="https://ajgqyygtstihrwjovhes.supabase.co/storage/v1/object/public/assets/config.js"></script>
    <script>
        // ============================================
        // CONFIGURATION - SET YOUR KEYS HERE
        // ============================================
        
        // üîë REQUIRED: Get this from your Supabase project settings
        // Dashboard ‚Üí Settings ‚Üí API ‚Üí Project URL
        const SUPABASE_URL = 'https://ajgqyygtstihrwjovhes.supabase.co';
        
        // üîë REQUIRED: Get this from your Supabase project settings
        // Dashboard ‚Üí Settings ‚Üí API ‚Üí Project API keys ‚Üí anon/public key
        // ‚ö†Ô∏è IMPORTANT: Replace this with your actual anon key!
        window.SUPABASE_ANON_KEY = window.SUPABASE_ANON_KEY || 'YOUR_SUPABASE_ANON_KEY_HERE';
        
        // If anon key is not set, show warning
        if (!window.SUPABASE_ANON_KEY || window.SUPABASE_ANON_KEY === 'YOUR_SUPABASE_ANON_KEY_HERE') {
            console.error('‚ö†Ô∏è SUPABASE_ANON_KEY not configured! Please set it in the script.');
        }
        
        const SUPABASE_ANON_KEY = window.SUPABASE_ANON_KEY;

        // Central configuration and feature flags
        const CONFIG = {
            supabase: { url: SUPABASE_URL, anonKey: SUPABASE_ANON_KEY },
            // Optionally set this in a script tag before this file: window.GOOGLE_MAPS_API_KEY = '<your key>'
            google: { apiKey: (window.GOOGLE_MAPS_API_KEY || '') },
            features: { enableFallback: true, enableRetries: true }
        };
        
        // ============================================
        // STATE MANAGEMENT
        // ============================================
        
        let wardIndex = { community: {} };
        let addressIndex = {};
        let addressIndexLoaded = false;
        let addressDatasetRows = null;
        let trackerCandidates = null;
        let autocompleteService = null;
        let geocoder = null;
        let isCurrentlyGeocoding = false;
        let isInitialized = false;
        let currentProvider = 'none'; // 'edge' | 'google' | 'none'
        let googleSdkLoaded = false;
        
        const addressInput = document.getElementById('addressInput');
        const dropdown = document.getElementById('autocompleteDropdown');
        const searchBtn = document.getElementById('searchBtn');
        let debounceTimer;
        
        // Rate limiting
        const rateLimiter = {
            requests: [],
            maxRequests: 10,
            windowMs: 60000,
            
            canMakeRequest() {
                const now = Date.now();
                this.requests = this.requests.filter(time => now - time < this.windowMs);
                
                if (this.requests.length >= this.maxRequests) {
                    return false;
                }
                
                this.requests.push(now);
                return true;
            }
        };
        
        // ============================================
        // PROXY SERVICES (SUPABASE EDGE FUNCTIONS)
        // ============================================
        
        const geocoderProxy = {
            geocode: async function(request, callback) {
                try {
                    const body = {
                        address: request.address,
                        region: request.region,
                    };
                    
                    if (request.location) {
                        const lat = typeof request.location.lat === 'function' ? request.location.lat() : (request.location.lat || request.location.latitude);
                        const lng = typeof request.location.lng === 'function' ? request.location.lng() : (request.location.lng || request.location.longitude);
                        if (typeof lat === 'number' && typeof lng === 'number') {
                            body['latlng'] = { lat, lng };
                        }
                    }
                    
                    const doFetch = () => fetch(`${SUPABASE_URL}/functions/v1/geocode`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'apikey': SUPABASE_ANON_KEY
                        },
                        body: JSON.stringify(body)
                    });

                    const resp = CONFIG.features.enableRetries
                        ? await withRetry(() => doFetch(), 2)
                        : await doFetch();
                    
                    if (!resp.ok) {
                        throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
                    }
                    
                    const data = await resp.json();
                    
                    if (data.status === 'OK') {
                        callback(data.results, 'OK');
                    } else {
                        callback(null, data.status || 'ERROR');
                    }
                } catch (err) {
                    console.error('Geocoder proxy error:', err);
                    callback(null, 'ERROR');
                }
            }
        };

        const autocompleteProxy = {
            getPlacePredictions: async function(request, callback) {
                try {
                    const bounds = request.bounds ? {
                        center: {
                            lat: (request.bounds.getNorthEast().lat() + request.bounds.getSouthWest().lat()) / 2,
                            lng: (request.bounds.getNorthEast().lng() + request.bounds.getSouthWest().lng()) / 2
                        },
                        radius: 20000
                    } : undefined;
                    const doFetch = () => fetch(`${SUPABASE_URL}/functions/v1/places-autocomplete`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${SUPABASE_ANON_KEY}`,
                            'apikey': SUPABASE_ANON_KEY
                        },
                        body: JSON.stringify({
                            input: request.input,
                            components: request.componentRestrictions ? `country:${request.componentRestrictions.country}` : undefined,
                            bounds
                        })
                    });

                    const resp = CONFIG.features.enableRetries
                        ? await withRetry(() => doFetch(), 2)
                        : await doFetch();
                    
                    if (!resp.ok) {
                        throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
                    }
                    
                    const data = await resp.json();
                    
                    if (data.status === 'OK') {
                        callback(data.predictions, 'OK');
                    } else {
                        callback(null, data.status || 'ERROR');
                    }
                } catch (err) {
                    console.error('Autocomplete proxy error:', err);
                    callback(null, 'ERROR');
                }
            }
        };
        // Geocoding/Autocomplete provider is selected dynamically in initializeGeocoding()
        
        // ============================================
        // UTILITY FUNCTIONS
        // ============================================
        
        function withTimeout(promise, timeoutMs = 10000) {
            return Promise.race([
                promise,
                new Promise((_, reject) => setTimeout(() => reject(new Error('Request timeout')), timeoutMs))
            ]);
        }

        async function withRetry(fn, maxRetries = 2, baseDelayMs = 800) {
            let attempt = 0;
            // Always try at least once
            for (;;) {
                try {
                    return await fn();
                } catch (error) {
                    if (attempt >= maxRetries) throw error;
                    const delayMs = Math.min(baseDelayMs * Math.pow(2, attempt), 5000);
                    await new Promise(res => setTimeout(res, delayMs));
                    attempt++;
                }
            }
        }

        async function loadGoogleMapsIfNeeded(apiKey) {
            if (googleSdkLoaded && window.google && window.google.maps) return true;
            if (!apiKey) return false;
            return new Promise(resolve => {
                const existing = document.querySelector('script[data-id="google-maps-sdk"]');
                if (existing) {
                    existing.addEventListener('load', () => {
                        googleSdkLoaded = true;
                        resolve(!!(window.google && window.google.maps));
                    });
                    return;
                }
                const script = document.createElement('script');
                script.src = `https://maps.googleapis.com/maps/api/js?key=${encodeURIComponent(apiKey)}&libraries=places`;
                script.async = true;
                script.defer = true;
                script.setAttribute('data-id', 'google-maps-sdk');
                script.onload = () => {
                    googleSdkLoaded = true;
                    resolve(!!(window.google && window.google.maps));
                };
                script.onerror = () => resolve(false);
                document.head.appendChild(script);
            });
        }

        async function ensureGoogleProvider() {
            if (currentProvider === 'google') return true;
            if (!CONFIG.features.enableFallback) return false;
            const ok = await loadGoogleMapsIfNeeded(CONFIG.google.apiKey);
            if (!ok) return false;
            try {
                geocoder = new google.maps.Geocoder();
                autocompleteService = new google.maps.places.AutocompleteService();
                currentProvider = 'google';
                showAlert('Switched to Google Maps fallback', 'info');
                return true;
            } catch (e) {
                return false;
            }
        }

        async function initializeGeocoding() {
            // Prefer Edge Functions when configured
            if (CONFIG.supabase.anonKey && CONFIG.supabase.anonKey !== 'YOUR_SUPABASE_ANON_KEY_HERE') {
                geocoder = geocoderProxy;
                autocompleteService = autocompleteProxy;
                currentProvider = 'edge';
            }
            // If not configured or unavailable, try Google fallback lazily
            if (!geocoder && CONFIG.google.apiKey) {
                const ok = await ensureGoogleProvider();
                if (!ok) console.warn('Google fallback not available; autocomplete/geocoding limited');
            }
        }
        
        function getUserFriendlyError(status) {
            const errors = {
                'REQUEST_DENIED': 'Unable to access location services. Please check the configuration.',
                'INVALID_REQUEST': 'Please enter a more complete address (e.g., "123 Main St SW, Calgary").',
                'ZERO_RESULTS': 'Address not found in Calgary. Please verify your address.',
                'OVER_QUERY_LIMIT': 'Too many searches. Please wait a moment and try again.',
                'UNKNOWN_ERROR': 'Something went wrong. Please try again.',
                'ERROR': 'Connection error. Please check your internet connection.'
            };
            return errors[status] || errors['UNKNOWN_ERROR'];
        }
        
        function normalizeKey(value) {
            return value.toUpperCase().trim()
                .replace(/\./g, '')
                .replace(/-/g, ' ')
                .replace(/\//g, ' ')
                .replace(/\s+/g, ' ')
                .replace(/\bN\s*E\b/g, 'NE')
                .replace(/\bN\s*W\b/g, 'NW')
                .replace(/\bS\s*E\b/g, 'SE')
                .replace(/\bS\s*W\b/g, 'SW')
                .replace(/\bNORTH\s*EAST\b/g, 'NE')
                .replace(/\bNORTH\s*WEST\b/g, 'NW')
                .replace(/\bSOUTH\s*EAST\b/g, 'SE')
                .replace(/\bSOUTH\s*WEST\b/g, 'SW');
        }

        function normalizeAddress(value) {
            return (value || '')
                .toUpperCase()
                .trim()
                .replace(/,\s*CANADA$/i, '')
                .replace(/,\s*ALBERTA$/i, '')
                .replace(/,\s*AB$/i, '')
                .replace(/,\s*CALGARY$/i, '')
                .replace(/\./g, '')
                .replace(/\s+/g, ' ')
                .replace(/\bNORTH[\s-]?EAST\b/g, 'NE')
                .replace(/\bNORTH[\s-]?WEST\b/g, 'NW')
                .replace(/\bSOUTH[\s-]?EAST\b/g, 'SE')
                .replace(/\bSOUTH[\s-]?WEST\b/g, 'SW')
                .replace(/\bSTREET\b/g, 'ST')
                .replace(/\bAVENUE\b/g, 'AVE')
                .replace(/\bROAD\b/g, 'RD')
                .replace(/\bDRIVE\b/g, 'DR')
                .replace(/\bCOURT\b/g, 'CT')
                .replace(/\bCRESCENT\b/g, 'CRES')
                .replace(/\bBOULEVARD\b/g, 'BLVD')
                .replace(/\bPLACE\b/g, 'PL')
                .replace(/\bWAY\b/g, 'WY')
                .trim();
        }

        function normalizeAddressVariations(value) {
            const base = normalizeAddress(value);
            const abbreviated = base
                .replace(/\bSTREET\b/g, 'ST')
                .replace(/\bAVENUE\b/g, 'AVE')
                .replace(/\bROAD\b/g, 'RD')
                .replace(/\bDRIVE\b/g, 'DR');
            const full = base
                .replace(/\bST\b/g, 'STREET')
                .replace(/\bAVE\b/g, 'AVENUE')
                .replace(/\bRD\b/g, 'ROAD')
                .replace(/\bDR\b/g, 'DRIVE');
            return Array.from(new Set([base, abbreviated, full]));
        }
        
        function isGenericLocation(name) {
            if (!name) return true;
            const normalized = normalizeKey(name);
            const generic = [
                'CALGARY',
                'NORTH EAST','NORTHEAST','NE',
                'NORTH WEST','NORTHWEST','NW',
                'SOUTH EAST','SOUTHEAST','SE',
                'SOUTH WEST','SOUTHWEST','SW',
                'DOWNTOWN','INNER CITY','DOWNTOWN CALGARY',
                'ALBERTA','AB',
                'CANADA','CA',
                'CITY OF CALGARY','CALGARY ALBERTA'
            ];
            
            if (generic.includes(normalized)) {
                return true;
            }
            
            if (normalized.endsWith(' CALGARY')) {
                const withoutCalgary = normalized.replace(/ CALGARY$/, '');
                if (generic.includes(withoutCalgary)) {
                    return true;
                }
            }
            return false;
        }
        
        // ============================================
        // DATA LOADING
        // ============================================
        
        async function loadWardMapping() {
            try {
                let filesLoaded = 0;
                for (let i = 1; i <= 14; i++) {
                    try {
                        const r = await fetch(`assets/data/calgary/wards/ward-${i}.json`);
                        if (r.ok) {
                            filesLoaded++;
                            const arr = await r.json();
                            arr.forEach(name => { wardIndex.community[normalizeKey(name)] = String(i); });
                        }
                    } catch (e) {
                        console.warn(`Ward ${i} not found`);
                    }
                }
                const communitiesCount = Object.keys(wardIndex.community).length;
                console.log('‚úÖ Ward mapping loaded:', communitiesCount, 'communities from', filesLoaded, 'files');
                if (filesLoaded === 0 || communitiesCount === 0) {
                    showAlert('Ward data unavailable. Search is disabled. Please try again later.', 'error');
                    const btn = document.getElementById('searchBtn');
                    if (btn) btn.disabled = true;
                }
            } catch (e) {
                console.error('‚ùå Failed to load wards:', e);
            }
        }

        async function loadAddressDataset() {
            console.log('Loading address dataset...');
            try {
                const url = 'https://ajgqyygtstihrwjovhes.supabase.co/storage/v1/object/public/YYC%20addresses/filtered_property_data.json';
                
                const res = await fetch(url, {
                    cache: 'no-store',
                    headers: { 'Accept': 'application/json' }
                });

                if (!res.ok) {
                    console.error('Failed to fetch dataset:', res.status);
                    return;
                }

                const json = await res.json();
                const rows = Array.isArray(json) ? json : (json && (json.rows || json.data)) || [];
                
                if (!Array.isArray(rows) || rows.length === 0) {
                    console.error('No valid rows in dataset');
                    return;
                }

                const sample = rows[0] || {};
                const { addressKey, communityKey } = detectAddressJsonKeys(sample);
                
                if (!addressKey || !communityKey) {
                    console.error('Could not detect address/community keys');
                    return;
                }

                const idx = {};
                let count = 0;
                
                for (const row of rows) {
                    const addr = String(row[addressKey] ?? '').trim();
                    const community = String(row[communityKey] ?? '').trim();
                    if (!addr || !community) continue;
                    const normalized = normalizeAddress(addr);
                    idx[normalized] = community;
                    count++;
                }
                
                if (count > 0) {
                    addressIndex = idx;
                    addressIndexLoaded = true;
                    addressDatasetRows = rows;
                    console.log('‚úÖ Address dataset loaded:', count.toLocaleString(), 'addresses');
                    
                    showAlert(`‚úì Loaded ${count.toLocaleString()} Calgary addresses for instant lookup`, 'success');
                    setTimeout(() => {
                        const alert = document.querySelector('.alert-success');
                        if (alert) alert.remove();
                    }, 4000);
                } else {
                    console.error('‚ùå No addresses loaded');
                }
            } catch (e) {
                console.error('‚ùå Failed to load address dataset:', e);
                showAlert('Address dataset unavailable. Will use online lookup.', 'info');
                setTimeout(() => {
                    const alert = document.querySelector('.alert-info');
                    if (alert) alert.remove();
                }, 4000);
            }
        }

        async function loadTrackerCandidates() {
            try {
                const res = await fetch('calgary-2025.html');
                if (!res.ok) return;
                const html = await res.text();
                const re = /const\s+candidates\s*=\s*\[(.*?)\];/s;
                const m = re.exec(html);
                if (!m) return;
                // Parse array in a controlled way; data is authored locally
                const parsed = Function('"use strict"; return [' + m[1] + '];')();
                // Sanitize to expected shape only
                const safe = Array.isArray(parsed) ? parsed.map(item => ({
                    position: String(item.position || ''),
                    ward: item.ward !== undefined ? String(item.ward) : (item.ward || ''),
                    name: String(item.name || ''),
                    url: item.url ? String(item.url) : undefined
                })).filter(c => c.name && c.position) : [];
                trackerCandidates = safe;
                console.log('‚úÖ Loaded candidates:', trackerCandidates.length);
            } catch (e) {
                console.error('Failed to load candidates:', e);
            }
        }

        function detectAddressJsonKeys(sample) {
            const keys = Object.keys(sample || {});
            let addressKey = null, communityKey = null;
            
            keys.forEach(k => {
                const l = k.toLowerCase();
                if (!addressKey && (l.includes('address') || l.includes('full_address') || l.includes('street'))) {
                    addressKey = k;
                }
                if (!communityKey && (l === 'com_name' || l.includes('community') || l.includes('neigh'))) {
                    communityKey = k;
                }
            });
            
            return { addressKey, communityKey };
        }
        
        // ============================================
        // AUTOCOMPLETE
        // ============================================
        
        addressInput.addEventListener('input', function(e) {
            clearTimeout(debounceTimer);
            const value = e.target.value.trim();

            if (!value) {
                dropdown.classList.remove('active');
                dropdown.innerHTML = '';
                const resultsEl = document.getElementById('resultsContainer');
                const alertEl = document.getElementById('alertContainer');
                if (resultsEl) resultsEl.innerHTML = '';
                if (alertEl) alertEl.innerHTML = '';
                isCurrentlyGeocoding = false;
                return;
            }
            
            const completePostalPattern = /^[A-Za-z]\d[A-Za-z][\s-]?\d[A-Za-z]\d$/;
            if (completePostalPattern.test(value)) {
                dropdown.classList.remove('active');
                debounceTimer = setTimeout(() => searchWard(), 500);
                return;
            }
            
            const partialPostalPattern = /^[A-Za-z]\d[A-Za-z][\s-]?\d?[A-Za-z]?\d?$/;
            if (partialPostalPattern.test(value)) {
                dropdown.classList.remove('active');
                return;
            }
            
            if (!value || value.length < 3 || !autocompleteService) {
                dropdown.classList.remove('active');
                return;
            }
            
            debounceTimer = setTimeout(() => {
                const bounds = {
                    getNorthEast: () => ({ lat: () => 51.2139, lng: () => -113.8668 }),
                    getSouthWest: () => ({ lat: () => 50.8429, lng: () => -114.3144 })
                };
                
                autocompleteService.getPlacePredictions({
                    input: value,
                    componentRestrictions: { country: 'ca' },
                    bounds
                }, displaySuggestions);
            }, 300);
        });

        function displaySuggestions(predictions, status) {
            dropdown.innerHTML = '';
            
            if (status !== 'OK' || !predictions || predictions.length === 0) {
                dropdown.classList.remove('active');
                return;
            }
            
            predictions.forEach(prediction => {
                const item = document.createElement('div');
                item.className = 'autocomplete-item';
                item.textContent = prediction.description;
                item.addEventListener('click', () => {
                    addressInput.value = prediction.description;
                    dropdown.classList.remove('active');
                    
                    const fromDataset = lookupInDataset(prediction.description);
                    if (fromDataset) {
                        lookupByCommunity(fromDataset, { source: 'Address dataset' });
                    } else {
                        geocodeAddress(prediction.description);
                    }
                });
                dropdown.appendChild(item);
            });
            
            dropdown.classList.add('active');
        }
        
        // ============================================
        // SEARCH & GEOCODING
        // ============================================
        
        function searchWard() {
            const address = addressInput.value.trim();
            
            if (!address) {
                showAlert('Please enter an address', 'error');
                return;
            }
            
            if (!rateLimiter.canMakeRequest()) {
                showAlert('Too many searches. Please wait a moment before trying again.', 'warning');
                return;
            }
            
            if (!geocoder) {
                showAlert('Location services not ready. Please wait a moment and try again.', 'error');
                return;
            }
            
            if (Object.keys(wardIndex.community).length === 0) {
                showAlert('Ward mapping not loaded. Please refresh the page.', 'info');
                return;
            }
            
            console.log('üîç Searching for:', address);
            
            const fromDataset = lookupInDataset(address);
            if (fromDataset) {
                console.log('‚úÖ Found in dataset:', fromDataset);
                lookupByCommunity(fromDataset, { source: 'Address dataset' });
                return;
            }
            
            geocodeAddress(address);
        }

        async function geocodeAddress(address) {
            if (isCurrentlyGeocoding) {
                console.log('Already geocoding, skipping');
                return;
            }
            
            isCurrentlyGeocoding = true;
            showLoadingWithTimeout();
            searchBtn.disabled = true;
            
            const geocodePromise = new Promise((resolve, reject) => {
                geocoder.geocode({ 
                    address: address + ', Calgary, AB', 
                    region: 'ca' 
                }, (results, status) => {
                    if (status === 'OK') resolve(results);
                    else reject(new Error(status));
                });
            });
            
            withTimeout(geocodePromise, 8000)
                .then((results) => {
                    if (!results || !results.length) {
                        showAlert('Address not found', 'error');
                        resetGeocodingState();
                        return;
                    }
                    
                    const best = results[0];
                    console.log('üìç Geocode result:', best.formatted_address);
                    
                    if (best.formatted_address) {
                        const fromDataset = lookupInDataset(best.formatted_address);
                        if (fromDataset) {
                            console.log('‚úÖ Found in dataset:', fromDataset);
                            lookupByCommunity(fromDataset, { source: 'Address dataset' });
                            resetGeocodingState();
                            return;
                        }
                    }
                    
                    const community = getCommunityFromComponents(best.address_components || []);
                    console.log('üèòÔ∏è Extracted community:', community);
                    
                    if (community && !isGenericLocation(community)) {
                        lookupByCommunity(community, { source: 'Google Geocoding' });
                        resetGeocodingState();
                        return;
                    }
                    
                    if (best.geometry && best.geometry.location) {
                        reverseGeocodeForCommunity(best.geometry.location);
                        return;
                    }
                    
                    showAlert('Could not determine community. Try a more complete street address.', 'error');
                    resetGeocodingState();
                })
                .catch(async (error) => {
                    console.error('Geocoding error:', error);
                    // Attempt fallback to Google SDK if available and not already on Google
                    const switched = await ensureGoogleProvider();
                    if (switched) {
                        // Retry once on Google
                        isCurrentlyGeocoding = false;
                        searchBtn.disabled = false;
                        return geocodeAddress(address);
                    }
                    showAlert(getUserFriendlyError(error.message || 'ERROR'), 'error');
                    resetGeocodingState();
                });
        }

        async function reverseGeocodeForCommunity(location) {
            console.log('üîÑ Reverse geocoding...');
            
            const reversePromise = new Promise((resolve, reject) => {
                geocoder.geocode({ location }, (results, status) => {
                    if (status === 'OK') resolve(results);
                    else reject(new Error(status));
                });
            });
            
            withTimeout(reversePromise, 8000)
                .then((results) => {
                    if (!results || !results.length) {
                        showAlert('Could not determine community', 'error');
                        resetGeocodingState();
                        return;
                    }
                    
                    console.log(`üìã Checking ${results.length} reverse geocode results`);
                    
                    if (addressIndexLoaded) {
                        for (let i = 0; i < Math.min(results.length, 20); i++) {
                            const result = results[i];
                            if (result.formatted_address) {
                                const fromDataset = lookupInDataset(result.formatted_address);
                                if (fromDataset) {
                                    console.log(`‚úÖ Found in dataset at result ${i}:`, fromDataset);
                                    lookupByCommunity(fromDataset, { source: 'Address dataset (reverse)' });
                                    resetGeocodingState();
                                    return;
                                }
                            }
                        }
                    }
                    
                    for (let i = 0; i < Math.min(results.length, 20); i++) {
                        const result = results[i];
                        const community = getCommunityFromComponents(result.address_components || []);
                        
                        if (community && !isGenericLocation(community)) {
                            const key = normalizeKey(community);
                            const ward = wardIndex.community[key];
                            
                            if (ward) {
                                console.log('‚úÖ Found community:', community);
                                lookupByCommunity(community, { source: 'Reverse geocoding' });
                                resetGeocodingState();
                                return;
                            }
                            
                            const fuzzy = findPartialCommunityMatch(key);
                            if (fuzzy) {
                                console.log('‚úÖ Fuzzy match:', fuzzy);
                                displayResults(fuzzy.ward, { 
                                    community: fuzzy.name, 
                                    note: 'Approximate match', 
                                    source: 'Reverse geocoding (fuzzy)' 
                                });
                                resetGeocodingState();
                                return;
                            }
                        }
                    }
                    
                    console.log('‚ùå All strategies failed');
                    showAlert('Could not find a specific community. Please try a nearby street address.', 'error');
                    resetGeocodingState();
                })
                .catch(async (error) => {
                    console.error('Reverse geocoding error:', error);
                    const switched = await ensureGoogleProvider();
                    if (switched) {
                        // Retry once on Google
                        isCurrentlyGeocoding = false;
                        searchBtn.disabled = false;
                        return reverseGeocodeForCommunity(location);
                    }
                    showAlert(getUserFriendlyError(error.message || 'ERROR'), 'error');
                    resetGeocodingState();
                });
        }

        function resetGeocodingState() {
            isCurrentlyGeocoding = false;
            searchBtn.disabled = false;
            hideLoading();
        }
        
        // ============================================
        // COMMUNITY EXTRACTION
        // ============================================
        
        function getCommunityFromComponents(components) {
            if (!components) return null;
            
            let candidates = {
                neighborhood: null,
                sublocality1: null,
                sublocality: null,
                political: null,
                colloquial: null
            };
            
            components.forEach(component => {
                const types = component.types || [];
                const name = component.long_name;
                
                const isTooGeneric = types.some(t =>
                    t === 'country' ||
                    t === 'administrative_area_level_1' ||
                    t === 'administrative_area_level_2' ||
                    t === 'locality' ||
                    t === 'postal_code'
                );
                
                if (isTooGeneric) return;
                
                if (types.includes('neighborhood')) candidates.neighborhood = name;
                if (types.includes('sublocality_level_1')) candidates.sublocality1 = name;
                if (types.includes('sublocality')) candidates.sublocality = name;
                if (types.includes('colloquial_area')) candidates.colloquial = name;
                if (types.includes('political') && !types.includes('locality')) candidates.political = name;
            });
            
            const priority = ['neighborhood', 'sublocality1', 'sublocality', 'colloquial', 'political'];
            for (const key of priority) {
                const candidate = candidates[key];
                if (candidate && !isGenericLocation(candidate)) {
                    return candidate;
                }
            }
            
            return null;
        }
        
        // ============================================
        // DATASET LOOKUP
        // ============================================
        
        function lookupInDataset(address) {
            if (!addressIndexLoaded) return null;
            
            const variations = normalizeAddressVariations(address);
            
            for (const variant of variations) {
                if (addressIndex[variant]) {
                    return addressIndex[variant];
                }
            }
            
            const patternMatch = findAddressByPattern(address);
            if (patternMatch) {
                return patternMatch;
            }
            
            return null;
        }

        function findAddressByPattern(address) {
            if (!addressIndexLoaded) return null;
            
            const match = (address || '').toUpperCase().match(/^(\d+)\s+(\d+[A-Z]?)\b/);
            if (!match) return null;
            
            const houseNum = match[1];
            const streetNum = match[2];
            const pattern = `${houseNum} ${streetNum}`.toUpperCase();
            
            const keys = Object.keys(addressIndex);
            const matches = keys.filter(k => k.startsWith(pattern));
            
            if (matches.length > 0) {
                return addressIndex[matches[0]];
            }
            
            return null;
        }

        function findPartialCommunityMatch(searchKey) {
            const key = normalizeKey(searchKey)
                .replace(/\s(NE|NW|SE|SW)$/g, '')
                .replace(/\sCALGARY$/g, '')
                .trim();
                
            if (key.length < 3) return null;
            
            const communities = Object.keys(wardIndex.community);
            for (const communityKey of communities) {
                if (communityKey.includes(key) || key.includes(communityKey)) {
                    return { ward: wardIndex.community[communityKey], name: communityKey };
                }
            }
            
            return null;
        }
        
        // ============================================
        // RESULTS DISPLAY
        // ============================================
        
        function lookupByCommunity(community, options = {}) {
            const key = normalizeKey(community);
            const ward = wardIndex.community[key];
            
            if (ward) {
                displayResults(ward, { ...options, community });
                return;
            }
            
            const partialMatch = findPartialCommunityMatch(key);
            if (partialMatch) {
                displayResults(partialMatch.ward, { 
                    ...options, 
                    community: partialMatch.name, 
                    note: 'Matched using similar community name' 
                });
                return;
            }
            
            console.log('‚ùå No match for community:', community);
            showAlert(`Community "${community}" not found. Please try your full street address.`, 'error');
            hideLoading();
        }

        function displayResults(ward, options = {}) {
            hideLoading();
            dropdown.classList.remove('active');
            searchBtn.disabled = false;
            
            const { mayors, councillors, cbe, ccsd } = getCandidatesForWard(ward);
            
            const header = `
                <div class="alert alert-success">
                    <span>‚úÖ</span>
                    <span>Matched${options.community ? ` ‚Äì ${options.community}` : ''}${options.note ? ` (${options.note})` : ''}</span>
                </div>
                <div class="ward-badge">
                    <h2>Your Ward</h2>
                    <div class="ward-number">Ward ${ward}</div>
                </div>
            `;

            const col = (title, icon, list) => `
              <div class="results-col">
                <h3><span class="section-icon">${icon}</span>${title}</h3>
                <div class="candidate-list">
                  ${list.length ? list.map(c => {
                    const name = c.url ? 
                        `<a href="${c.url}" target="_blank" rel="noopener" class="candidate-name">${c.name}</a>` : 
                        `<span class="candidate-name">${c.name}</span>`;
                    return `<div class="candidate-card">${name}</div>`;
                  }).join('') : '<div class="alert alert-info">No entries</div>'}
                </div>
              </div>`;

            const grid = `
              <div class="results-grid">
                ${col('Mayor', 'üë§', mayors)}
                ${col(`Councillor (Ward ${ward})`, 'üë•', councillors)}
                ${col('CBE Trustees', 'üè´', cbe)}
                ${col('CCSD Trustees', '‚õ™', ccsd)}
              </div>`;

            document.getElementById('resultsContainer').innerHTML = header + grid;
            
            console.log(`‚úÖ Displayed results for Ward ${ward}`);
        }

        function getCandidatesForWard(ward) {
            const wardStr = String(ward);
            const empty = { mayors: [], councillors: [], cbe: [], ccsd: [] };
            
            if (!Array.isArray(trackerCandidates)) return empty;
            
            const mayors = trackerCandidates.filter(c => c.position === 'Mayor');
            const councillors = trackerCandidates.filter(c => c.position === 'Councillor' && String(c.ward) === wardStr);
            
            const cbePairs = {
              '1': ['1 & 2'], '2': ['1 & 2'], '3': ['3 & 4'], '4': ['3 & 4'],
              '5': ['5 & 10'], '10': ['5 & 10'], '6': ['6 & 7'], '7': ['6 & 7'],
              '8': ['8 & 9'], '9': ['8 & 9'], '11': ['11 & 13'], '13': ['11 & 13'],
              '12': ['12 & 14'], '14': ['12 & 14']
            };
            
            const ccsdPairs = {
              '1': ['1, 2 & Cochrane'], '2': ['1, 2 & Cochrane'],
              '4': ['4 & 7'], '7': ['4 & 7'], '6': ['6 & 8'], '8': ['6 & 8'],
              '9': ['9 & 10'], '10': ['9 & 10'], '11': ['11 & 12'], '12': ['11 & 12'],
              '13': ['13 & 14'], '14': ['13 & 14']
            };
            
            const cbe = trackerCandidates.filter(c => 
                c.position === 'CBE Trustee' && 
                (cbePairs[wardStr] || []).includes(String(c.ward))
            );
            
            const ccsd = trackerCandidates.filter(c => 
                c.position === 'CCSD Trustee' && 
                (ccsdPairs[wardStr] || []).includes(String(c.ward))
            );
            
            return { mayors, councillors, cbe, ccsd };
        }
        
        // ============================================
        // UI HELPERS
        // ============================================
        
        function showAlert(message, type) {
            const icons = { 
                error: '‚ùå', 
                success: '‚úÖ', 
                info: '‚ÑπÔ∏è',
                warning: '‚ö†Ô∏è'
            };
            
            document.getElementById('alertContainer').innerHTML = `
                <div class="alert alert-${type}">
                    <span>${icons[type]}</span>
                    <span>${message}</span>
                </div>
            `;
            
            setTimeout(() => {
                const alert = document.querySelector(`.alert-${type}`);
                if (alert) alert.remove();
            }, 5000);
        }

        function showLoadingWithTimeout() {
            showLoading();
            
            setTimeout(() => {
                const loadingDiv = document.querySelector('.loading');
                if (loadingDiv && isCurrentlyGeocoding) {
                    loadingDiv.innerHTML = `
                        <div class="spinner"></div>
                        <p>Still searching...</p>
                        <p style="font-size: 0.9rem; color: #666; margin-top: 10px;">
                            This is taking longer than usual. Please wait...
                        </p>
                    `;
                }
            }, 5000);
        }

        function showLoading() {
            document.getElementById('resultsContainer').innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Searching...</p>
                </div>
            `;
        }

        function hideLoading() {
            const loadingDiv = document.querySelector('.loading');
            if (loadingDiv) loadingDiv.remove();
        }
        
        // ============================================
        // EVENT LISTENERS
        // ============================================
        
        document.addEventListener('click', function(e) {
            if (!addressInput.contains(e.target) && !dropdown.contains(e.target)) {
                dropdown.classList.remove('active');
            }
        });

        addressInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                dropdown.classList.remove('active');
                searchWard();
            }
        });
        
        // ============================================
        // INITIALIZATION
        // ============================================
        
        async function initialize() {
            console.log('üöÄ Initializing Calgary Voter Guide...');
            // Initialize provider selection (Edge if configured, otherwise Google if available)
            await initializeGeocoding();
            
            await Promise.all([
                loadWardMapping(),
                loadAddressDataset(),
                loadTrackerCandidates()
            ]);
            
            isInitialized = true;
            console.log('‚úÖ Initialization complete');
            
            // Expose debug helpers
            window.calgaryVoterGuide = {
                status: () => ({
                    provider: currentProvider,
                    initialized: isInitialized,
                    wards: Object.keys(wardIndex.community).length,
                    addresses: Object.keys(addressIndex).length,
                    candidates: Array.isArray(trackerCandidates) ? trackerCandidates.length : 0
                }),
                test: (addr) => { addressInput.value = addr; searchWard(); },
                config: CONFIG
            };
        }
        
        initialize();
        
        // ============================================
        // DEBUG HELPERS (accessible via console)
        // ============================================
        
        window.debugDatasetLookup = function(testAddress) {
            console.log('Dataset loaded:', addressIndexLoaded);
            console.log('Dataset size:', Object.keys(addressIndex).length);
            
            const addr = (testAddress || addressInput.value || '').trim();
            console.log('\nüîç Testing address:', addr);
            
            const res = lookupInDataset(addr);
            console.log('Result:', res || 'NOT FOUND');
        };
        
        window.testWard = function(address) {
            addressInput.value = address;
            searchWard();
        };
        
        console.log('üí° Debug commands available:');
        console.log('  - debugDatasetLookup("123 Main St")');
        console.log('  - testWard("Calgary Tower")');
    </script>
</body>
</html>
