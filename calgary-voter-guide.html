<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Calgary Voter Guide - Find Your Ward & Candidates</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; color: #333; }
        .container { max-width: 1200px; margin: 0 auto; }
        .header { text-align: center; color: white; margin-bottom: 40px; animation: fadeInDown 0.8s ease; }
        .header h1 { font-size: 3rem; font-weight: 800; margin-bottom: 10px; text-shadow: 2px 2px 4px rgba(0,0,0,0.2); }
        .header p { font-size: 1.2rem; opacity: 0.95; }
        .main-card { background: white; border-radius: 24px; padding: 40px; box-shadow: 0 20px 60px rgba(0,0,0,0.3); animation: fadeInUp 0.8s ease; margin-bottom: 30px; }
        .search-section { margin-bottom: 30px; }
        .input-group { position: relative; margin-bottom: 20px; }
        .input-group label { display: block; font-weight: 600; margin-bottom: 8px; color: #555; font-size: 0.95rem; }
        .address-input-wrapper { position: relative; }
        input[type="text"] { width: 100%; padding: 18px 50px 18px 20px; font-size: 1.1rem; border: 2px solid #e0e0e0; border-radius: 16px; transition: all 0.3s ease; background: #f8f9fa; }
        input[type="text"]:focus { outline: none; border-color: #667eea; background: white; box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1); }
        .input-icon { position: absolute; right: 18px; top: 50%; transform: translateY(-50%); color: #999; }
        .autocomplete-dropdown { position: absolute; top: 100%; left: 0; right: 0; background: white; border: 2px solid #e0e0e0; border-top: none; border-radius: 0 0 16px 16px; max-height: 300px; overflow-y: auto; z-index: 1000; box-shadow: 0 10px 30px rgba(0,0,0,0.1); display: none; }
        .autocomplete-dropdown.active { display: block; }
        .autocomplete-item { padding: 15px 20px; cursor: pointer; border-bottom: 1px solid #f0f0f0; transition: background 0.2s; }
        .autocomplete-item:hover { background: #f8f9fa; }
        .search-btn { width: 100%; padding: 18px; font-size: 1.2rem; font-weight: 700; color: white; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; border-radius: 16px; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4); }
        .search-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6); }
        .alert { padding: 16px 20px; border-radius: 12px; margin-bottom: 20px; display: flex; align-items: center; gap: 12px; animation: slideIn 0.4s ease; }
        .alert-error { background: #fee; border: 2px solid #fcc; color: #c33; }
        .alert-success { background: #efe; border: 2px solid #cfc; color: #3c3; }
        .alert-info { background: #eef; border: 2px solid #ccf; color: #33c; }
        .ward-badge { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 20px; text-align: center; margin-bottom: 30px; box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3); animation: scaleIn 0.5s ease; }
        .ward-badge h2 { font-size: 1.5rem; margin-bottom: 10px; opacity: 0.9; }
        .ward-badge .ward-number { font-size: 4rem; font-weight: 900; text-shadow: 2px 2px 4px rgba(0,0,0,0.2); }
        .candidates-section { margin-bottom: 30px; }
        .section-title { font-size: 1.8rem; font-weight: 700; margin-bottom: 20px; color: #333; display: flex; align-items: center; gap: 12px; }
        .section-icon { width: 40px; height: 40px; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 1.5rem; }
        .mayor-icon { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        .councillor-icon { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
        .candidate-list { display: flex; flex-direction: column; gap: 15px; }
        .candidate-card { background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); padding: 20px 25px; border-radius: 16px; display: flex; align-items: center; gap: 20px; transition: all 0.3s ease; border: 2px solid transparent; }
        .candidate-card:hover { transform: translateX(8px); border-color: #667eea; box-shadow: 0 8px 20px rgba(0,0,0,0.1); }
        .candidate-name { font-size: 1.3rem; font-weight: 600; color: #333; text-decoration: none; }
        .candidate-name:hover { color: #667eea; }
        .loading { text-align: center; padding: 40px; color: #999; }
        .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #667eea; border-radius: 50%; width: 50px; height: 50px; animation: spin 1s linear infinite; margin: 0 auto 20px; }
        @keyframes fadeInDown { from { opacity: 0; transform: translateY(-30px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeInUp { from { opacity: 0; transform: translateY(30px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes slideIn { from { opacity: 0; transform: translateX(-20px); } to { opacity: 1; transform: translateX(0); } }
        @keyframes scaleIn { from { opacity: 0; transform: scale(0.9); } to { opacity: 1; transform: scale(1); } }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üó≥Ô∏è Calgary Voter Guide</h1>
            <p>Find your ward and recommended candidates</p>
        </div>
        <div class="main-card">
            <div class="search-section">
                <div class="input-group">
                    <label for="addressInput">Enter Your Address or Postal Code</label>
                    <div class="address-input-wrapper">
                        <input type="text" id="addressInput" placeholder="123 Main St SW, Calgary or T2P 3M5" autocomplete="off">
                        <span class="input-icon">üìç</span>
                        <div id="autocompleteDropdown" class="autocomplete-dropdown"></div>
                    </div>
                </div>
                <button class="search-btn" onclick="searchWard()">üîç Find My Ward & Candidates</button>
            </div>
            <div id="alertContainer"></div>
            <div id="resultsContainer"></div>
        </div>
    </div>
    <script>
        const GOOGLE_MAPS_API_KEY = 'AIzaSyDrt3pufqoeYZlipaTBmYPvpBMSRwwdg9s';
        let wardIndex = { community: {} };
        let addressIndex = {}; // normalizedAddress -> community
        let addressIndexLoaded = false;
        let trackerCandidates = null;
        let autocompleteService = null;
        let geocoder = null;
        const addressInput = document.getElementById('addressInput');
        const dropdown = document.getElementById('autocompleteDropdown');
        let debounceTimer;

        function initGoogleMaps() {
            const script = document.createElement('script');
            script.src = `https://maps.googleapis.com/maps/api/js?key=${GOOGLE_MAPS_API_KEY}&libraries=places&callback=initServices`;
            script.async = true;
            script.defer = true;
            script.onerror = () => {
                showAlert('Failed to load Google Maps. Check API key and referrer restrictions.', 'error');
                console.error('Google Maps JS failed to load');
            };
            document.head.appendChild(script);
        }

        function initServices() {
            autocompleteService = new google.maps.places.AutocompleteService();
            geocoder = new google.maps.Geocoder();
            console.log('Google Maps initialized');
        }
        // Ensure callback is globally accessible
        window.initServices = initServices;

        async function loadAddressDataset() {
            try {
                const url = 'https://ajgqyygtstihrwjovhes.supabase.co/storage/v1/object/public/YYC%20addresses/filtered_property_data.json';
                const res = await fetch(url, { cache: 'no-store' });
                if (!res.ok) return;
                const json = await res.json();
                const rows = Array.isArray(json) ? json : (json && (json.rows || json.data)) || [];
                if (!Array.isArray(rows)) return;
                const sample = rows[0] || {};
                const { addressKey, communityKey } = detectAddressJsonKeys(sample);
                if (!addressKey || !communityKey) return;
                const idx = {};
                let count = 0;
                for (const row of rows) {
                    const addr = String(row[addressKey] ?? '').trim();
                    const community = String(row[communityKey] ?? '').trim();
                    if (!addr || !community) continue;
                    idx[normalizeAddress(addr)] = community;
                    count++;
                }
                if (count > 0) {
                    addressIndex = idx;
                    addressIndexLoaded = true;
                    console.log('Address index loaded:', count);
                }
            } catch (e) {
                console.warn('Failed to load address dataset', e);
            }
        }

        async function loadWardMapping() {
            try {
                for (let i = 1; i <= 14; i++) {
                    try {
                        const r = await fetch(`assets/data/calgary/wards/ward-${i}.json`);
                        if (r.ok) {
                            const arr = await r.json();
                            arr.forEach(name => { wardIndex.community[normalizeKey(name)] = String(i); });
                        }
                    } catch (e) { console.warn(`Ward ${i} not found`); }
                }
                console.log('Ward mapping loaded:', Object.keys(wardIndex.community).length);
            } catch (e) { console.error('Failed to load wards:', e); }
        }

        async function loadTrackerCandidates() {
            try {
                const res = await fetch('calgary-2025.html');
                if (!res.ok) return;
                const html = await res.text();
                const re = /const\s+candidates\s*=\s*\[(.*?)\];/s;
                const m = re.exec(html);
                if (!m) return;
                trackerCandidates = Function('"use strict"; return [' + m[1] + '];')();
                console.log('Loaded candidates:', trackerCandidates.length);
            } catch (e) { console.error('Failed to load candidates:', e); }
        }

        addressInput.addEventListener('input', function(e) {
            clearTimeout(debounceTimer);
            const value = e.target.value.trim();
            const completePostalPattern = /^[A-Za-z]\d[A-Za-z][\s-]?\d[A-Za-z]\d$/;
            if (completePostalPattern.test(value)) {
                dropdown.classList.remove('active');
                debounceTimer = setTimeout(() => searchWard(), 500);
                return;
            }
            const partialPostalPattern = /^[A-Za-z]\d[A-Za-z][\s-]?\d?[A-Za-z]?\d?$/;
            if (partialPostalPattern.test(value)) {
                dropdown.classList.remove('active');
                return;
            }
            if (!value || value.length < 3 || !autocompleteService) {
                dropdown.classList.remove('active');
                return;
            }
            debounceTimer = setTimeout(() => {
                const bounds = new google.maps.LatLngBounds(
                    new google.maps.LatLng(50.8429, -114.3144),
                    new google.maps.LatLng(51.2139, -113.8668)
                );
                autocompleteService.getPlacePredictions({
                    input: value,
                    componentRestrictions: { country: 'ca' },
                    bounds
                }, displaySuggestions);
            }, 300);
        });

        function displaySuggestions(predictions, status) {
            dropdown.innerHTML = '';
            const ok = (google.maps.places.PlacesServiceStatus && google.maps.places.PlacesServiceStatus.OK)
              || (google.maps.places.AutocompleteServiceStatus && google.maps.places.AutocompleteServiceStatus.OK);
            if (status !== ok || !predictions || predictions.length === 0) {
                dropdown.classList.remove('active');
                if (typeof status === 'string' && status !== ok) {
                    // Surface common misconfigurations for easier debugging
                    if (status === 'REQUEST_DENIED') {
                        showAlert('Autocomplete request denied. Ensure Places API is enabled and referrer/domain is allowed.', 'error');
                    } else if (status === 'INVALID_REQUEST') {
                        showAlert('Invalid autocomplete request. Try typing a fuller address.', 'error');
                    }
                }
                return;
            }
            predictions.forEach(prediction => {
                const item = document.createElement('div');
                item.className = 'autocomplete-item';
                item.textContent = prediction.description;
                item.addEventListener('click', () => {
                    addressInput.value = prediction.description;
                    dropdown.classList.remove('active');
                    // Prefer dataset match first
                    const fromDataset = addressIndex[normalizeAddress(prediction.description)];
                    if (fromDataset) {
                        lookupByCommunity(fromDataset, { source: 'Address dataset' });
                    } else {
                        geocodeAddress(prediction.description);
                    }
                });
                dropdown.appendChild(item);
            });
            dropdown.classList.add('active');
        }

        function searchWard() {
            const address = addressInput.value.trim();
            if (!address) { showAlert('Please enter an address', 'error'); return; }
            if (Object.keys(wardIndex.community).length === 0) { showAlert('Ward mapping not loaded', 'info'); return; }
            // Dataset first
            if (addressIndexLoaded) {
                const fromDataset = addressIndex[normalizeAddress(address)];
                if (fromDataset) {
                    lookupByCommunity(fromDataset, { source: 'Address dataset' });
                    return;
                }
            }
            geocodeAddress(address);
        }

        function geocodeAddress(address) {
            showLoading();
            geocoder.geocode({ address: address + ', Calgary, AB' }, (results, status) => {
                if (status === 'OK' && results && results.length) {
                    const best = results[0];
                    // Try dataset again using Google's normalized formatted_address
                    if (addressIndexLoaded && best && best.formatted_address) {
                        const fromDataset = addressIndex[normalizeAddress(best.formatted_address)];
                        if (fromDataset) {
                            lookupByCommunity(fromDataset, { source: 'Address dataset' });
                            return;
                        }
                    }

                    const community = getCommunityFromComponents(best.address_components || []);
                    if (community) {
                        lookupByCommunity(community, { source: 'Google Geocoding' });
                    } else if (best.geometry && best.geometry.location) {
                        // Reverse geocode fall-back path to search for neighborhood/sublocality
                        geocoder.geocode({ location: best.geometry.location }, (revResults, revStatus) => {
                            if (revStatus === 'OK' && revResults && revResults.length) {
                                for (let i = 0; i < revResults.length; i++) {
                                    const c = getCommunityFromComponents(revResults[i].address_components || []);
                                    if (c) {
                                        lookupByCommunity(c, { source: 'Google Geocoding (reverse)' });
                                        return;
                                    }
                                }
                            }
                            showAlert('Could not determine community', 'error');
                            hideLoading();
                        });
                    } else {
                        showAlert('Could not determine community', 'error');
                        hideLoading();
                    }
                } else {
                    showAlert('Address not found', 'error');
                    hideLoading();
                }
            });
        }

        function getCommunityFromComponents(components) {
            if (!components) return null;
            let neighborhood = null, sublocality = null, colloquial = null, sublocality1 = null;
            components.forEach(component => {
                const types = component.types || [];
                if (types.includes('neighborhood')) neighborhood = component.long_name;
                if (types.includes('sublocality')) sublocality = component.long_name;
                if (types.includes('sublocality_level_1')) sublocality1 = component.long_name;
                if (types.includes('colloquial_area')) colloquial = component.long_name;
            });
            const candidate = neighborhood || sublocality1 || sublocality || colloquial || null;
            // Filter out generic quadrants and city-wide names
            if (!candidate) return null;
            if (/^(CALGARY|NORTH\s*EAST|NORTH\s*WEST|SOUTH\s*EAST|SOUTH\s*WEST|NE|NW|SE|SW)$/i.test(candidate)) return null;
            return candidate;
        }

        function lookupByCommunity(community) {
            const key = normalizeKey(community);
            const ward = wardIndex.community[key];
            if (ward) {
                displayResults(ward, { community });
            } else {
                showAlert(`Community "${community}" not mapped`, 'error');
                hideLoading();
            }
        }

        function displayResults(ward, options = {}) {
            hideLoading();
            dropdown.classList.remove('active');
            const { mayors, councillors } = getCandidatesForWard(ward);
            let html = `<div class="alert alert-success"><span>‚úÖ</span><span>Matched${options.community ? ` ‚Äì ${options.community}` : ''}</span></div>`;
            html += `<div class="ward-badge"><h2>Your Ward</h2><div class="ward-number">Ward ${ward}</div></div>`;
            if (mayors.length > 0) {
                html += `<div class="candidates-section"><h3 class="section-title"><span class="section-icon mayor-icon">üë§</span>Mayor Candidates</h3><div class="candidate-list">`;
                mayors.forEach(c => {
                    const name = c.url ? `<a href="${c.url}" target="_blank" rel="noopener" class="candidate-name">${c.name}</a>` : `<span class="candidate-name">${c.name}</span>`;
                    html += `<div class="candidate-card">${name}</div>`;
                });
                html += `</div></div>`;
            }
            if (councillors.length > 0) {
                html += `<div class="candidates-section"><h3 class="section-title"><span class="section-icon councillor-icon">üë•</span>Councillor Candidates (Ward ${ward})</h3><div class="candidate-list">`;
                councillors.forEach(c => {
                    const name = c.url ? `<a href="${c.url}" target="_blank" rel="noopener" class="candidate-name">${c.name}</a>` : `<span class="candidate-name">${c.name}</span>`;
                    html += `<div class="candidate-card">${name}</div>`;
                });
                html += `</div></div>`;
            }
            if (mayors.length === 0 && councillors.length === 0) {
                html += `<div class="alert alert-info"><span>‚ÑπÔ∏è</span><span>No candidate data available</span></div>`;
            }
            document.getElementById('resultsContainer').innerHTML = html;
        }

        function getCandidatesForWard(ward) {
            const wardStr = String(ward);
            const empty = { mayors: [], councillors: [] };
            if (!Array.isArray(trackerCandidates)) return empty;
            return {
                mayors: trackerCandidates.filter(c => c.position === 'Mayor'),
                councillors: trackerCandidates.filter(c => c.position === 'Councillor' && String(c.ward) === wardStr)
            };
        }

        function showAlert(message, type) {
            const icons = { error: '‚ùå', success: '‚úÖ', info: '‚ÑπÔ∏è' };
            document.getElementById('alertContainer').innerHTML = `<div class="alert alert-${type}"><span>${icons[type]}</span><span>${message}</span></div>`;
            setTimeout(() => { document.getElementById('alertContainer').innerHTML = ''; }, 5000);
        }

        function showLoading() {
            document.getElementById('resultsContainer').innerHTML = `<div class="loading"><div class="spinner"></div><p>Searching...</p></div>`;
        }

        function hideLoading() {
            const loadingDiv = document.querySelector('.loading');
            if (loadingDiv) loadingDiv.remove();
        }

        function normalizeKey(value) {
            return value.toUpperCase().trim()
                .replace(/\./g, '')
                .replace(/-/g, ' ')
                .replace(/\//g, ' ')
                .replace(/\s+/g, ' ')
                .replace(/\bN\s*E\b/g, 'NE')
                .replace(/\bN\s*W\b/g, 'NW')
                .replace(/\bS\s*E\b/g, 'SE')
                .replace(/\bS\s*W\b/g, 'SW')
                .replace(/\bNORTH\s*EAST\b/g, 'NE')
                .replace(/\bNORTH\s*WEST\b/g, 'NW')
                .replace(/\bSOUTH\s*EAST\b/g, 'SE')
                .replace(/\bSOUTH\s*WEST\b/g, 'SW');
        }

        function normalizeAddress(value) {
            return (value || '')
                .toUpperCase().trim()
                .replace(/\./g, '')
                .replace(/\s+/g, ' ')
                .replace(/,\s*CANADA$/i, '')
                .replace(/,\s*ALBERTA$/i, '')
                .replace(/,\s*AB$/i, '')
                .replace(/,\s*CALGARY$/i, '')
                .replace(/\bNORTH\s*EAST\b/g, 'NE')
                .replace(/\bNORTH\s*WEST\b/g, 'NW')
                .replace(/\bSOUTH\s*EAST\b/g, 'SE')
                .replace(/\bSOUTH\s*WEST\b/g, 'SW')
                .replace(/\bST\b/g, 'STREET')
                .replace(/\bAVE\b/g, 'AVENUE')
                .replace(/\bRD\b/g, 'ROAD')
                .replace(/\bDR\b/g, 'DRIVE');
        }

        function detectAddressJsonKeys(sample) {
            const keys = Object.keys(sample || {});
            let addressKey = null, communityKey = null;
            keys.forEach(k => {
                const l = k.toLowerCase();
                if (!addressKey && (l.includes('address') || l.includes('full_address') || l.includes('street'))) addressKey = k;
                if (!communityKey && (l === 'com_name' || l.includes('community') || l.includes('neigh'))) communityKey = k;
            });
            return { addressKey, communityKey };
        }

        document.addEventListener('click', function(e) {
            if (!addressInput.contains(e.target) && !dropdown.contains(e.target)) {
                dropdown.classList.remove('active');
            }
        });

        addressInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                dropdown.classList.remove('active');
                searchWard();
            }
        });

        initGoogleMaps();
        loadWardMapping();
        loadAddressDataset();
        loadTrackerCandidates();
    </script>
</body>
</html>
